## Описание процесса сдачи лабораторных

### Получение доступа к репозиторию
- Зарегистрироваться на github.com (если аккаунта еще нет)
- Предоставить никнейм аккаунта в:
	- [Таблицу с результатами](https://docs.google.com/spreadsheets/d/1G7bA58RaUNy-v9zGdhKY1r7nZxCOG4FJomj8uyv9GNk)
	- [Группу в ВКонакте](https://vk.com/topic-186371582_40033557)
- После этого дождаться подтверждения того, что вас добавили в команду репозитория
	- Ответом от преподавателя
	- ваш никнейм в общей таблице выделен зеленым
- Принять приглашение к совместной работе над репозторием (приходит на почту)
### Правила работы с репозиторием
- Вся работа ведется в вашей персональной ветке
	- Ветка должна именоваться `<group>_<FirstName>-<LastName>`
	- Избегайте использования символов `/ , \ . | * +`
	- Не забывайте по завершении работы делать push в удаленную ветку
- По возможности старайтесь сделать красивую историю коммитов в ней
- ЗАПРЕЩАЕТСЯ ОПРАВЛЯТЬ ИЗМЕНЕНИЯ В ВЕТКУ master
	- Все ваши коммиты из ветки master будут удалены
	- Кара воспоследует
### Отметки о сдаче задания
- Выполнив задание и отправив его код в свою ветку в репозиторий, отметьте соответствующий чекбокс в [Таблице с результатами](https://docs.google.com/spreadsheets/d/1G7bA58RaUNy-v9zGdhKY1r7nZxCOG4FJomj8uyv9GNk)
- После проверки преподавателем в этой таблице будет отмечено выполнение задание:
	- Зеленый - все хорошо
	- Желтый - принято, но можно лучше
	- Оранжевый - есть замечания, требующие исправления
	- Красный - задание не найдено, задание не выполнено, задание списано
	- Будет добавлен комментарий с замечаниями, после исправления замечаний стоит добавить свой комментарий в трек
### Задания
#### Scala  - 1
- В данном задании необходимо реализовать простые функции, используя рекурсию (допускается использование дополнительных "внутренних" функции)
- Функции
	- `def pascal(c: Int, r: Int): Int` - функция возвращающая значение элемента треугольника Паскаля по номеру колонки и строки
  
	![треугольник Паскаля](https://upload.wikimedia.org/wikipedia/commons/7/71/%D0%A2%D1%80%D0%B5%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_%D0%9F%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D1%8F.png)
	- ` def balance(chars: List[Char]): Boolean` - функция, подсчитывающая баланс скобок в выражении (по открытым и закрытым скобкам)
	- `def countChange(money: Int, coins: List[Int])` - функция, определяющая количество возможных вариантов размена суммы (`money`) монетами номиналом (`coins`)
#### Scala  - 2
- В это задании необходимо реализовать множество целых числе заданное как функцию `type Set = Int => Boolean`, данная функция отвечает на вопрос "содержится ли заданный элемент в множестве", выделяя его таким образом из множества целых чисел
- Для выполнения задания необходимо представить свою реализацию функций, тело которых представлено как `???`
- После выполнения задания, подумайте над тем, где все-таки хранятся элементы множества
#### Scala  - 3
- Анаграмма слова - это перестановка его букв так, что образуется слово с другим значением. Например, если мы переставляем буквы слова `Elvis`, мы можем получить слово `lives`, которое является одной из его анаграмм.
- Анаграмма предложения - это перестановка всех символов в предложении так, что формируется новое предложение. Новое предложение состоит из значащих слов, количество которых может соответствовать или не соответствовать количеству слов в исходном предложении. Например, предложение: `I love you` - это анаграмма предложения `you olive` 
- При создании анаграмм мы будем игнорировать регистр символов и знаки препинания.
- Ваша конечная цель состоит в том, чтобы реализовать функцию, который, учитывая список слов, представляющих предложение, находит все анаграммы этого предложения. - Обратите внимание, что мы использовали термин «значимый» для определения анаграмм. Вам будет предоставлен словарь, то есть список слов, обозначающих слова, которые имеют значение.
- Общая идея:
	- Преобразовать символы предложения в список, содержащий пары - (символ, частота его появления в предложении)
	- Чтобы найти анаграммы слова, нужно найти слова из словаря, которые имеют одинаковый список вхождений. 
	- Чтобы найти анаграмму предложения необходимо извлечь из него любое подмножество символов, и попытаться сформировать какие-либо значимые слова. Из оставшихся символов мы решим задачу рекурсивно, а затем объединим все значимые слова, которые мы нашли, с рекурсивным решением.
#### Clojure
#### Haskell
- Необходимо реализовать вычисление расстояния Хемминга для двух ДНК.
- [Исходное описание задачи](http://rosalind.info/problems/hamm/)
- Для запуска базовых тестов (рекомендуется дополнять своими) `stack test`
 - Для использования интерактивной среды `stack ghci`
- [Установка и настройка Haskell](https://www.haskell.org/downloads)
### Курсовик (расчетно-графическая работа)
#### Простой
- Данные варианты курсовика рекомендованы для тех, кому совсем неинтересно и хочется потратить минимум времени для его написания:
	1. Реализовать интерфейс к лабораторной Scala-3
		- Ввод предложения
		- Вывод анаграммы
		- Редактирование словаря
	2. Аналогично 1, но вместо интерфейса использовать файлы
	3. Калькулятор 
#### Средний
- Данные варианты курсовика рекомендованы для тех, кому хочется сделать что-то новое, но при этом не потратить на это много времени:
	1. Кластеризация точек - реализовать считывание точек из файла и отображение на графике (для построения графика выбрать любую библиотеку). Количество точек от 1 миллиона. Варианты (выбрать один):
		- В двумерном пространстве
		- В трехмерном пространстве
	2. Аналогично 1, но в качестве интерфейса веб (с использованием akka.http)
	3. Реализовать веб-интерфейс к лабораторной Scala-3 (с использованием akka.http) и сохранением словаря в БД (sqlite, mongodb, postgresql)
	4. Реализовать построение множества Мандельброта и представления его в виде картинки. Варианты:
		- Без использования actors
		- С использованием actors (akka)
	5. Реализовать перемножение матриц с использованием actors (akka)
#### Интересный
- Данные варианты курсовика рекомендованы для тех, кому интересно поглубже нырнуть в функциональное программирование и реализовать что-то необычное:
	1. Реализовать простой многослойный перцептрон, максимально используя только чистые функции. Тестировать можно на базе MNIST
	2. Реализовать простой многослойный перцептрон с использованием actors (akka). Тестировать можно на базе MNIST
	3. Реализовать распознавание цифр (MNIST) с использование существующих библиотек, например [DeepLearning.scala](https://github.com/ThoughtWorksInc/DeepLearning.scala/)

#### Свой собственный
Вы можете предложить любой интересный вам вариант курсовика, главное условие - активное использование подходов функционального программирования

